/*****************************************************************************
 * dvd_css.c: Functions for DVD authentification and unscrambling
 *****************************************************************************
 * Copyright (C) 1999-2001 VideoLAN
 * $Id: dvd_css.c,v 1.7 2001/02/13 10:08:51 stef Exp $
 *
 * Author: Stéphane Borel <stef@via.ecp.fr>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
 *****************************************************************************/

/*****************************************************************************
 * Preamble
 *****************************************************************************/
#include "defs.h"

#if defined( HAVE_SYS_DVDIO_H ) || defined( LINUX_DVD )

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <netinet/in.h>
#ifdef HAVE_SYS_IOCTL_H
# include <sys/ioctl.h>
#endif
#ifdef HAVE_SYS_DVDIO_H
# include <sys/dvdio.h>
#endif
#ifdef LINUX_DVD
# include <linux/cdrom.h>
#endif

#include "common.h"
#include "intf_msg.h"
#include "dvd_css.h"
#include "dvd_ifo.h"
#include "input_dvd.h"

/*****************************************************************************
 * CSS tables
 *****************************************************************************/
static u8 pi_css_tab1[256]=
{   0x33, 0x73, 0x3b, 0x26, 0x63, 0x23, 0x6b, 0x76,
    0x3e, 0x7e, 0x36, 0x2b, 0x6e, 0x2e, 0x66, 0x7b,
    0xd3, 0x93, 0xdb, 0x06, 0x43, 0x03, 0x4b, 0x96,
    0xde, 0x9e, 0xd6, 0x0b, 0x4e, 0x0e, 0x46, 0x9b,
    0x57, 0x17, 0x5f, 0x82, 0xc7, 0x87, 0xcf, 0x12,
    0x5a, 0x1a, 0x52, 0x8f, 0xca, 0x8a, 0xc2, 0x1f,
    0xd9, 0x99, 0xd1, 0x00, 0x49, 0x09, 0x41, 0x90,
    0xd8, 0x98, 0xd0, 0x01, 0x48, 0x08, 0x40, 0x91,
    0x3d, 0x7d, 0x35, 0x24, 0x6d, 0x2d, 0x65, 0x74,
    0x3c, 0x7c, 0x34, 0x25, 0x6c, 0x2c, 0x64, 0x75,
    0xdd, 0x9d, 0xd5, 0x04, 0x4d, 0x0d, 0x45, 0x94,
    0xdc, 0x9c, 0xd4, 0x05, 0x4c, 0x0c, 0x44, 0x95,
    0x59, 0x19, 0x51, 0x80, 0xc9, 0x89, 0xc1, 0x10,
    0x58, 0x18, 0x50, 0x81, 0xc8, 0x88, 0xc0, 0x11,
    0xd7, 0x97, 0xdf, 0x02, 0x47, 0x07, 0x4f, 0x92,
    0xda, 0x9a, 0xd2, 0x0f, 0x4a, 0x0a, 0x42, 0x9f,
    0x53, 0x13, 0x5b, 0x86, 0xc3, 0x83, 0xcb, 0x16,
    0x5e, 0x1e, 0x56, 0x8b, 0xce, 0x8e, 0xc6, 0x1b,
    0xb3, 0xf3, 0xbb, 0xa6, 0xe3, 0xa3, 0xeb, 0xf6,
    0xbe, 0xfe, 0xb6, 0xab, 0xee, 0xae, 0xe6, 0xfb,
    0x37, 0x77, 0x3f, 0x22, 0x67, 0x27, 0x6f, 0x72,
    0x3a, 0x7a, 0x32, 0x2f, 0x6a, 0x2a, 0x62, 0x7f,
    0xb9, 0xf9, 0xb1, 0xa0, 0xe9, 0xa9, 0xe1, 0xf0,
    0xb8, 0xf8, 0xb0, 0xa1, 0xe8, 0xa8, 0xe0, 0xf1,
    0x5d, 0x1d, 0x55, 0x84, 0xcd, 0x8d, 0xc5, 0x14,
    0x5c, 0x1c, 0x54, 0x85, 0xcc, 0x8c, 0xc4, 0x15,
    0xbd, 0xfd, 0xb5, 0xa4, 0xed, 0xad, 0xe5, 0xf4,
    0xbc, 0xfc, 0xb4, 0xa5, 0xec, 0xac, 0xe4, 0xf5,
    0x39, 0x79, 0x31, 0x20, 0x69, 0x29, 0x61, 0x70,
    0x38, 0x78, 0x30, 0x21, 0x68, 0x28, 0x60, 0x71,
    0xb7, 0xf7, 0xbf, 0xa2, 0xe7, 0xa7, 0xef, 0xf2,
    0xba, 0xfa, 0xb2, 0xaf, 0xea, 0xaa, 0xe2, 0xff
};

static u8 pi_css_tab2[256]=
{   0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x09, 0x08, 0x0b, 0x0a, 0x0d, 0x0c, 0x0f, 0x0e,
    0x12, 0x13, 0x10, 0x11, 0x16, 0x17, 0x14, 0x15,
    0x1b, 0x1a, 0x19, 0x18, 0x1f, 0x1e, 0x1d, 0x1c,
    0x24, 0x25, 0x26, 0x27, 0x20, 0x21, 0x22, 0x23,
    0x2d, 0x2c, 0x2f, 0x2e, 0x29, 0x28, 0x2b, 0x2a,
    0x36, 0x37, 0x34, 0x35, 0x32, 0x33, 0x30, 0x31,
    0x3f, 0x3e, 0x3d, 0x3c, 0x3b, 0x3a, 0x39, 0x38,
    0x49, 0x48, 0x4b, 0x4a, 0x4d, 0x4c, 0x4f, 0x4e,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    0x5b, 0x5a, 0x59, 0x58, 0x5f, 0x5e, 0x5d, 0x5c,
    0x52, 0x53, 0x50, 0x51, 0x56, 0x57, 0x54, 0x55,
    0x6d, 0x6c, 0x6f, 0x6e, 0x69, 0x68, 0x6b, 0x6a,
    0x64, 0x65, 0x66, 0x67, 0x60, 0x61, 0x62, 0x63,
    0x7f, 0x7e, 0x7d, 0x7c, 0x7b, 0x7a, 0x79, 0x78,
    0x76, 0x77, 0x74, 0x75, 0x72, 0x73, 0x70, 0x71,
    0x92, 0x93, 0x90, 0x91, 0x96, 0x97, 0x94, 0x95,
    0x9b, 0x9a, 0x99, 0x98, 0x9f, 0x9e, 0x9d, 0x9c,
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
    0x89, 0x88, 0x8b, 0x8a, 0x8d, 0x8c, 0x8f, 0x8e,
    0xb6, 0xb7, 0xb4, 0xb5, 0xb2, 0xb3, 0xb0, 0xb1,
    0xbf, 0xbe, 0xbd, 0xbc, 0xbb, 0xba, 0xb9, 0xb8,
    0xa4, 0xa5, 0xa6, 0xa7, 0xa0, 0xa1, 0xa2, 0xa3,
    0xad, 0xac, 0xaf, 0xae, 0xa9, 0xa8, 0xab, 0xaa,
    0xdb, 0xda, 0xd9, 0xd8, 0xdf, 0xde, 0xdd, 0xdc,
    0xd2, 0xd3, 0xd0, 0xd1, 0xd6, 0xd7, 0xd4, 0xd5,
    0xc9, 0xc8, 0xcb, 0xca, 0xcd, 0xcc, 0xcf, 0xce,
    0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
    0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8,
    0xf6, 0xf7, 0xf4, 0xf5, 0xf2, 0xf3, 0xf0, 0xf1,
    0xed, 0xec, 0xef, 0xee, 0xe9, 0xe8, 0xeb, 0xea,
    0xe4, 0xe5, 0xe6, 0xe7, 0xe0, 0xe1, 0xe2, 0xe3
};

static u8 pi_css_tab3[512]=
{   0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff,
    0x00, 0x24, 0x49, 0x6d, 0x92, 0xb6, 0xdb, 0xff
};

static u8 pi_css_tab4[256]=
{   0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
};

static u8 pi_css_tab5[256]=
{   0xff, 0x7f, 0xbf, 0x3f, 0xdf, 0x5f, 0x9f, 0x1f,
    0xef, 0x6f, 0xaf, 0x2f, 0xcf, 0x4f, 0x8f, 0x0f,
    0xf7, 0x77, 0xb7, 0x37, 0xd7, 0x57, 0x97, 0x17,
    0xe7, 0x67, 0xa7, 0x27, 0xc7, 0x47, 0x87, 0x07,
    0xfb, 0x7b, 0xbb, 0x3b, 0xdb, 0x5b, 0x9b, 0x1b,
    0xeb, 0x6b, 0xab, 0x2b, 0xcb, 0x4b, 0x8b, 0x0b,
    0xf3, 0x73, 0xb3, 0x33, 0xd3, 0x53, 0x93, 0x13,
    0xe3, 0x63, 0xa3, 0x23, 0xc3, 0x43, 0x83, 0x03,
    0xfd, 0x7d, 0xbd, 0x3d, 0xdd, 0x5d, 0x9d, 0x1d,
    0xed, 0x6d, 0xad, 0x2d, 0xcd, 0x4d, 0x8d, 0x0d,
    0xf5, 0x75, 0xb5, 0x35, 0xd5, 0x55, 0x95, 0x15,
    0xe5, 0x65, 0xa5, 0x25, 0xc5, 0x45, 0x85, 0x05,
    0xf9, 0x79, 0xb9, 0x39, 0xd9, 0x59, 0x99, 0x19,
    0xe9, 0x69, 0xa9, 0x29, 0xc9, 0x49, 0x89, 0x09,
    0xf1, 0x71, 0xb1, 0x31, 0xd1, 0x51, 0x91, 0x11,
    0xe1, 0x61, 0xa1, 0x21, 0xc1, 0x41, 0x81, 0x01,
    0xfe, 0x7e, 0xbe, 0x3e, 0xde, 0x5e, 0x9e, 0x1e,
    0xee, 0x6e, 0xae, 0x2e, 0xce, 0x4e, 0x8e, 0x0e,
    0xf6, 0x76, 0xb6, 0x36, 0xd6, 0x56, 0x96, 0x16,
    0xe6, 0x66, 0xa6, 0x26, 0xc6, 0x46, 0x86, 0x06,
    0xfa, 0x7a, 0xba, 0x3a, 0xda, 0x5a, 0x9a, 0x1a,
    0xea, 0x6a, 0xaa, 0x2a, 0xca, 0x4a, 0x8a, 0x0a,
    0xf2, 0x72, 0xb2, 0x32, 0xd2, 0x52, 0x92, 0x12,
    0xe2, 0x62, 0xa2, 0x22, 0xc2, 0x42, 0x82, 0x02,
    0xfc, 0x7c, 0xbc, 0x3c, 0xdc, 0x5c, 0x9c, 0x1c,
    0xec, 0x6c, 0xac, 0x2c, 0xcc, 0x4c, 0x8c, 0x0c,
    0xf4, 0x74, 0xb4, 0x34, 0xd4, 0x54, 0x94, 0x14,
    0xe4, 0x64, 0xa4, 0x24, 0xc4, 0x44, 0x84, 0x04,
    0xf8, 0x78, 0xb8, 0x38, 0xd8, 0x58, 0x98, 0x18,
    0xe8, 0x68, 0xa8, 0x28, 0xc8, 0x48, 0x88, 0x08,
    0xf0, 0x70, 0xb0, 0x30, 0xd0, 0x50, 0x90, 0x10,
    0xe0, 0x60, 0xa0, 0x20, 0xc0, 0x40, 0x80, 0x00
};

/* Mangle tables usesd for key decryption */
static u8 pi_css_mangle0[256] =
{
    0x00, 0x81, 0x03, 0x82, 0x06, 0x87, 0x05, 0x84,
    0x0C, 0x8D, 0x0F, 0x8E, 0x0A, 0x8B, 0x09, 0x88,
    0x18, 0x99, 0x1B, 0x9A, 0x1E, 0x9F, 0x1D, 0x9C,
    0x14, 0x95, 0x17, 0x96, 0x12, 0x93, 0x11, 0x90,
    0x30, 0xB1, 0x33, 0xB2, 0x36, 0xB7, 0x35, 0xB4,
    0x3C, 0xBD, 0x3F, 0xBE, 0x3A, 0xBB, 0x39, 0xB8,
    0x28, 0xA9, 0x2B, 0xAA, 0x2E, 0xAF, 0x2D, 0xAC,
    0x24, 0xA5, 0x27, 0xA6, 0x22, 0xA3, 0x21, 0xA0,
    0x60, 0xE1, 0x63, 0xE2, 0x66, 0xE7, 0x65, 0xE4,
    0x6C, 0xED, 0x6F, 0xEE, 0x6A, 0xEB, 0x69, 0xE8,
    0x78, 0xF9, 0x7B, 0xFA, 0x7E, 0xFF, 0x7D, 0xFC,
    0x74, 0xF5, 0x77, 0xF6, 0x72, 0xF3, 0x71, 0xF0,
    0x50, 0xD1, 0x53, 0xD2, 0x56, 0xD7, 0x55, 0xD4,
    0x5C, 0xDD, 0x5F, 0xDE, 0x5A, 0xDB, 0x59, 0xD8,
    0x48, 0xC9, 0x4B, 0xCA, 0x4E, 0xCF, 0x4D, 0xCC,
    0x44, 0xC5, 0x47, 0xC6, 0x42, 0xC3, 0x41, 0xC0,
    0xC0, 0x41, 0xC3, 0x42, 0xC6, 0x47, 0xC5, 0x44,
    0xCC, 0x4D, 0xCF, 0x4E, 0xCA, 0x4B, 0xC9, 0x48,
    0xD8, 0x59, 0xDB, 0x5A, 0xDE, 0x5F, 0xDD, 0x5C,
    0xD4, 0x55, 0xD7, 0x56, 0xD2, 0x53, 0xD1, 0x50,
    0xF0, 0x71, 0xF3, 0x72, 0xF6, 0x77, 0xF5, 0x74,
    0xFC, 0x7D, 0xFF, 0x7E, 0xFA, 0x7B, 0xF9, 0x78,
    0xE8, 0x69, 0xEB, 0x6A, 0xEE, 0x6F, 0xED, 0x6C,
    0xE4, 0x65, 0xE7, 0x66, 0xE2, 0x63, 0xE1, 0x60,
    0xA0, 0x21, 0xA3, 0x22, 0xA6, 0x27, 0xA5, 0x24,
    0xAC, 0x2D, 0xAF, 0x2E, 0xAA, 0x2B, 0xA9, 0x28,
    0xB8, 0x39, 0xBB, 0x3A, 0xBE, 0x3F, 0xBD, 0x3C,
    0xB4, 0x35, 0xB7, 0x36, 0xB2, 0x33, 0xB1, 0x30,
    0x90, 0x11, 0x93, 0x12, 0x96, 0x17, 0x95, 0x14,
    0x9C, 0x1D, 0x9F, 0x1E, 0x9A, 0x1B, 0x99, 0x18,
    0x88, 0x09, 0x8B, 0x0A, 0x8E, 0x0F, 0x8D, 0x0C,
    0x84, 0x05, 0x87, 0x06, 0x82, 0x03, 0x81, 0x00
    };

static u8 pi_css_mangle1[256] =
{
    0xC4, 0xCD, 0xCE, 0xCB, 0xC8, 0xC9, 0xCA, 0xCF,
    0xCC, 0xC5, 0xC6, 0xC3, 0xC0, 0xC1, 0xC2, 0xC7,
    0x14, 0x1D, 0x1E, 0x1B, 0x18, 0x19, 0x1A, 0x1F,
    0x1C, 0x15, 0x16, 0x13, 0x10, 0x11, 0x12, 0x17,
    0x24, 0x2D, 0x2E, 0x2B, 0x28, 0x29, 0x2A, 0x2F,
    0x2C, 0x25, 0x26, 0x23, 0x20, 0x21, 0x22, 0x27,
    0x34, 0x3D, 0x3E, 0x3B, 0x38, 0x39, 0x3A, 0x3F,
    0x3C, 0x35, 0x36, 0x33, 0x30, 0x31, 0x32, 0x37,
    0x04, 0x0D, 0x0E, 0x0B, 0x08, 0x09, 0x0A, 0x0F,
    0x0C, 0x05, 0x06, 0x03, 0x00, 0x01, 0x02, 0x07,
    0xD4, 0xDD, 0xDE, 0xDB, 0xD8, 0xD9, 0xDA, 0xDF,
    0xDC, 0xD5, 0xD6, 0xD3, 0xD0, 0xD1, 0xD2, 0xD7,
    0xE4, 0xED, 0xEE, 0xEB, 0xE8, 0xE9, 0xEA, 0xEF,
    0xEC, 0xE5, 0xE6, 0xE3, 0xE0, 0xE1, 0xE2, 0xE7,
    0xF4, 0xFD, 0xFE, 0xFB, 0xF8, 0xF9, 0xFA, 0xFF,
    0xFC, 0xF5, 0xF6, 0xF3, 0xF0, 0xF1, 0xF2, 0xF7,
    0x44, 0x4D, 0x4E, 0x4B, 0x48, 0x49, 0x4A, 0x4F,
    0x4C, 0x45, 0x46, 0x43, 0x40, 0x41, 0x42, 0x47,
    0x94, 0x9D, 0x9E, 0x9B, 0x98, 0x99, 0x9A, 0x9F,
    0x9C, 0x95, 0x96, 0x93, 0x90, 0x91, 0x92, 0x97,
    0xA4, 0xAD, 0xAE, 0xAB, 0xA8, 0xA9, 0xAA, 0xAF,
    0xAC, 0xA5, 0xA6, 0xA3, 0xA0, 0xA1, 0xA2, 0xA7,
    0xB4, 0xBD, 0xBE, 0xBB, 0xB8, 0xB9, 0xBA, 0xBF,
    0xBC, 0xB5, 0xB6, 0xB3, 0xB0, 0xB1, 0xB2, 0xB7,
    0x84, 0x8D, 0x8E, 0x8B, 0x88, 0x89, 0x8A, 0x8F,
    0x8C, 0x85, 0x86, 0x83, 0x80, 0x81, 0x82, 0x87,
    0x54, 0x5D, 0x5E, 0x5B, 0x58, 0x59, 0x5A, 0x5F,
    0x5C, 0x55, 0x56, 0x53, 0x50, 0x51, 0x52, 0x57,
    0x64, 0x6D, 0x6E, 0x6B, 0x68, 0x69, 0x6A, 0x6F,
    0x6C, 0x65, 0x66, 0x63, 0x60, 0x61, 0x62, 0x67,
    0x74, 0x7D, 0x7E, 0x7B, 0x78, 0x79, 0x7A, 0x7F,
    0x7C, 0x75, 0x76, 0x73, 0x70, 0x71, 0x72, 0x77
};

static u8 pi_css_mangle2[256] =
{
    0xC4, 0x24, 0x14, 0x34, 0xCE, 0x2E, 0x1E, 0x3E,
    0xCD, 0x2D, 0x1D, 0x3D, 0xCB, 0x2B, 0x1B, 0x3B,
    0x44, 0xA4, 0x94, 0xB4, 0x4E, 0xAE, 0x9E, 0xBE,
    0x4D, 0xAD, 0x9D, 0xBD, 0x4B, 0xAB, 0x9B, 0xBB,
    0x04, 0xE4, 0xD4, 0xF4, 0x0E, 0xEE, 0xDE, 0xFE,
    0x0D, 0xED, 0xDD, 0xFD, 0x0B, 0xEB, 0xDB, 0xFB,
    0x84, 0x64, 0x54, 0x74, 0x8E, 0x6E, 0x5E, 0x7E,
    0x8D, 0x6D, 0x5D, 0x7D, 0x8B, 0x6B, 0x5B, 0x7B,
    0xCC, 0x2C, 0x1C, 0x3C, 0xC6, 0x26, 0x16, 0x36,
    0xC5, 0x25, 0x15, 0x35, 0xC3, 0x23, 0x13, 0x33,
    0x4C, 0xAC, 0x9C, 0xBC, 0x46, 0xA6, 0x96, 0xB6,
    0x45, 0xA5, 0x95, 0xB5, 0x43, 0xA3, 0x93, 0xB3,
    0x0C, 0xEC, 0xDC, 0xFC, 0x06, 0xE6, 0xD6, 0xF6,
    0x05, 0xE5, 0xD5, 0xF5, 0x03, 0xE3, 0xD3, 0xF3,
    0x8C, 0x6C, 0x5C, 0x7C, 0x86, 0x66, 0x56, 0x76,
    0x85, 0x65, 0x55, 0x75, 0x83, 0x63, 0x53, 0x73,
    0xC8, 0x28, 0x18, 0x38, 0xCA, 0x2A, 0x1A, 0x3A,
    0xC9, 0x29, 0x19, 0x39, 0xCF, 0x2F, 0x1F, 0x3F,
    0x48, 0xA8, 0x98, 0xB8, 0x4A, 0xAA, 0x9A, 0xBA,
    0x49, 0xA9, 0x99, 0xB9, 0x4F, 0xAF, 0x9F, 0xBF,
    0x08, 0xE8, 0xD8, 0xF8, 0x0A, 0xEA, 0xDA, 0xFA,
    0x09, 0xE9, 0xD9, 0xF9, 0x0F, 0xEF, 0xDF, 0xFF,
    0x88, 0x68, 0x58, 0x78, 0x8A, 0x6A, 0x5A, 0x7A,
    0x89, 0x69, 0x59, 0x79, 0x8F, 0x6F, 0x5F, 0x7F,
    0xC0, 0x20, 0x10, 0x30, 0xC2, 0x22, 0x12, 0x32,
    0xC1, 0x21, 0x11, 0x31, 0xC7, 0x27, 0x17, 0x37,
    0x40, 0xA0, 0x90, 0xB0, 0x42, 0xA2, 0x92, 0xB2,
    0x41, 0xA1, 0x91, 0xB1, 0x47, 0xA7, 0x97, 0xB7,
    0x00, 0xE0, 0xD0, 0xF0, 0x02, 0xE2, 0xD2, 0xF2,
    0x01, 0xE1, 0xD1, 0xF1, 0x07, 0xE7, 0xD7, 0xF7,
    0x80, 0x60, 0x50, 0x70, 0x82, 0x62, 0x52, 0x72,
    0x81, 0x61, 0x51, 0x71, 0x87, 0x67, 0x57, 0x77
};

static u8 pi_reverse[256] =
{
    0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
    0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
    0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
    0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
    0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
    0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
    0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
    0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
    0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
    0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
    0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
    0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
    0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
    0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
    0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
    0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
    0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
    0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
    0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
    0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
    0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
    0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
    0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
    0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
    0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
    0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
    0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
    0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
    0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
    0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
    0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
    0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};

/*
 * Local functions
 */

/*****************************************************************************
 * CSSGetASF : Get Authentification success flag
 * ---
 * Returns :
 *  -1 on ioctl error,
 *  0 if the device needs to be authenticated,
 *  1 either.
 *****************************************************************************/
static int CSSGetASF( int i_fd )
{
    dvd_authinfo    auth_info;

    auth_info.type = DVD_LU_SEND_ASF;
    auth_info.lsasf.asf = 0;

    for( auth_info.lsasf.agid = 0 ; auth_info.lsasf.agid < 4 ;
                                                    auth_info.lsasf.agid++ )
    {
        if( !( ioctl( i_fd, DVD_AUTH, &auth_info ) ) )
        {
            intf_WarnMsg( 3, "CSS: %sAuthenticated",
                                    ( auth_info.lsasf.asf ) ? "" : "not " );
            return auth_info.lsasf.asf;
        }
    }

    /* The ioctl process has failed */
    intf_ErrMsg( "CSS: GetASF Fatal Error" );
    return -1;
}

/*****************************************************************************
 * CSSCryptKey : shuffles bits and unencrypt keys.
 * Used during authentication and disc key negociation in CSSInit.
 * ---
 * i_key_type : 0->key1, 1->key2, 2->buskey.
 * i_varient : between 0 and 31.
 *****************************************************************************/
static void CSSCryptKey( int i_key_type, int i_varient,
                         u8 const * pi_challenge, u8* pi_key )
{
    /* "Secret" key */
    u8      pi_css_secret[5] = { 0xE2, 0xA3, 0x45, 0x10, 0xF4 };

    /* Permutation table for challenge */
    u8      ppi_perm_challenge[3][10] =
            { { 1, 3, 0, 7, 5, 2, 9, 6, 4, 8 },
              { 6, 1, 9, 3, 8, 5, 7, 4, 0, 2 },
              { 4, 0, 3, 5, 7, 2, 8, 6, 1, 9 } };

    /* Permutation table for varient table for key2 and buskey */
    u8      ppi_perm_varient[2][32] =
            { { 0x0a, 0x08, 0x0e, 0x0c, 0x0b, 0x09, 0x0f, 0x0d,
                0x1a, 0x18, 0x1e, 0x1c, 0x1b, 0x19, 0x1f, 0x1d,
                0x02, 0x00, 0x06, 0x04, 0x03, 0x01, 0x07, 0x05,
                0x12, 0x10, 0x16, 0x14, 0x13, 0x11, 0x17, 0x15 },
              { 0x12, 0x1a, 0x16, 0x1e, 0x02, 0x0a, 0x06, 0x0e,
                0x10, 0x18, 0x14, 0x1c, 0x00, 0x08, 0x04, 0x0c,
                0x13, 0x1b, 0x17, 0x1f, 0x03, 0x0b, 0x07, 0x0f,
                0x11, 0x19, 0x15, 0x1d, 0x01, 0x09, 0x05, 0x0d } };

    /* CSS varient for mangling */
    u8      pi_css_varients[32] =
              { 0x00, 0x01, 0x04, 0x05, 0x10, 0x11, 0x14, 0x15,
                0x20, 0x21, 0x24, 0x25, 0x30, 0x31, 0x34, 0x35,
                0x80, 0x81, 0x84, 0x85, 0x90, 0x91, 0x94, 0x95,
                0xA0, 0xA1, 0xA4, 0xA5, 0xB0, 0xB1, 0xB4, 0xB5 };
    u8      pi_bits[30];
    u8      pi_scratch[10];
    u8      pi_tmp1[5];
    u8      pi_tmp2[5];
    u8      i_lfsr0_o;
    u8      i_lfsr1_o;
    u32     i_lfsr0;
    u32     i_lfsr1;
    u8      i_css_varient;
    int     i_val = 0;
    int     i_term = 0;
    int     i, i_index;

    for( i=0 ; i<10 ; i++ )
    {
        pi_scratch[i] = pi_challenge[ppi_perm_challenge[i_key_type][i]];
    }
    i_css_varient = i_key_type == 0 ? i_varient
                    : ppi_perm_varient[i_key_type-1][i_varient];

    for( i=0 ; i<5 ; i++ )
    {
        pi_tmp1[i] = pi_scratch[5+i] ^ pi_css_secret[i];
    }

    /* In order to ensure that the LFSR works we need to ensure that the
     * initial values are non-zero.  Thus when we initialise them from
     * the seed,  we ensure that a bit is set.
     */
    i_lfsr0 = ( pi_tmp1[0] << 17 ) | ( pi_tmp1[1] << 9 ) |
              ( ( pi_tmp1[2] & ~7 ) << 1 ) | 8 | (pi_tmp1[2] & 7);


    /*
     * reverse lfsr0/1 to simplify calculation in loop
     */
    i_lfsr0 = ( pi_reverse[i_lfsr0 & 0xff] << 17 ) |
              ( pi_reverse[( i_lfsr0 >> 8 ) & 0xff] << 9 ) |
              ( pi_reverse[( i_lfsr0 >> 16 ) & 0xff] << 1) |
              ( i_lfsr0 >> 24 );

    i_lfsr1 = ( pi_reverse[pi_tmp1[4]] << 9 ) | 0x100 |
              ( pi_reverse[pi_tmp1[3]] );

    i_index = sizeof( pi_bits );

    do
    {
        i_lfsr0_o = ( i_lfsr0 >> 12) ^ ( i_lfsr0 >> 4) ^
                    ( i_lfsr0 >> 3) ^ i_lfsr0;

        i_lfsr1_o = ( ( i_lfsr1 >> 14 ) & 7) ^ i_lfsr1;
        i_lfsr1_o ^= ( i_lfsr1_o << 3 ) ^ ( i_lfsr1_o << 6 );

        i_lfsr1 = ( i_lfsr1 >> 8) ^ ( i_lfsr1_o << 9);
        i_lfsr0 = ( i_lfsr0 >> 8 ) ^ ( i_lfsr0_o << 17);

        i_lfsr0_o = ~i_lfsr0_o;
        i_lfsr1_o = ~i_lfsr1_o;

        i_val += i_lfsr0_o + i_lfsr1_o;

        pi_bits[--i_index] = i_val & 0xFF;
        i_val >>= 8;

    } while( i_index > 0 );

    i_css_varient = pi_css_varients[i_css_varient];

    /*
     * Mangling
     */
    for( i = 5, i_term = 0 ; --i >= 0 ; i_term = pi_scratch[i] )
    {
        i_index = pi_bits[25+i] ^ pi_scratch[i];
        i_index = pi_css_mangle1[i_index] ^ i_css_varient;
        pi_tmp1[i] = pi_css_mangle2[i_index] ^ i_term;
    }
    pi_tmp1[4] ^= pi_tmp1[0];

    for( i = 5, i_term = 0 ; --i >= 0 ; i_term = pi_tmp1[i] )
    {
        i_index = pi_bits[20+i] ^ pi_tmp1[i];
        i_index = pi_css_mangle1[i_index] ^ i_css_varient;
        pi_tmp2[i] = pi_css_mangle2[i_index] ^ i_term;
    }
    pi_tmp2[4] ^= pi_tmp2[0];

    for( i = 5, i_term = 0 ; --i >= 0 ; i_term = pi_tmp2[i] )
    {
        i_index = pi_bits[15+i] ^ pi_tmp2[i];
        i_index = pi_css_mangle1[i_index] ^ i_css_varient;
        i_index = pi_css_mangle2[i_index] ^ i_term;
        pi_tmp1[i] = pi_css_mangle0[i_index];
    }
    pi_tmp1[4] ^= pi_tmp1[0];

    for( i = 5, i_term = 0 ; --i >= 0 ; i_term = pi_tmp1[i] )
    {
        i_index = pi_bits[10+i] ^ pi_tmp1[i];
        i_index = pi_css_mangle1[i_index] ^ i_css_varient;
        i_index = pi_css_mangle2[i_index] ^ i_term;
        pi_tmp2[i] = pi_css_mangle0[i_index];
    }
    pi_tmp2[4] ^= pi_tmp2[0];

    for( i = 5, i_term = 0 ; --i >= 0 ; i_term = pi_tmp2[i] )
    {
        i_index = pi_bits[5+i] ^ pi_tmp2[i];
        i_index = pi_css_mangle1[i_index] ^ i_css_varient;
        pi_tmp1[i] = pi_css_mangle2[i_index] ^ i_term;
    }
    pi_tmp1[4] ^= pi_tmp1[0];

    for( i=5, i_term=0 ; --i>=0 ; i_term=pi_tmp1[i] )
    {
        i_index = pi_bits[i] ^ pi_tmp1[i];
        i_index = pi_css_mangle1[i_index] ^ i_css_varient;
        pi_key[i] = pi_css_mangle2[i_index] ^ i_term;
    }

    return;
}

/*****************************************************************************
 * CSSCracker : title key decryption by cracking
 * ---
 * This function is called by CSSGetKeys to find a key
 *****************************************************************************/
static int CSSCracker( int i_start,
                       unsigned char * p_crypted,
                       unsigned char * p_decrypted,
                       DVD_key_t * p_sector_key,
                       DVD_key_t * p_key )
{
    unsigned char pi_buffer[10];
    unsigned int i_t1, i_t2, i_t3, i_t4, i_t5, i_t6;
    unsigned int i_try;
    unsigned int i_candidate;
    unsigned int i, j;
    int i_exit = -1;


    for( i = 0 ; i < 10 ; i++ )
    {
        pi_buffer[i] = pi_css_tab1[p_crypted[i]] ^ p_decrypted[i];
    }

    for( i_try = i_start ; i_try < 0x10000 ; i_try++ )
    {
        i_t1 = i_try >> 8 | 0x100;
        i_t2 = i_try & 0xff;
        i_t3 = 0;               /* not needed */
        i_t5 = 0;

        /* iterate cipher 4 times to reconstruct LFSR2 */
        for( i = 0 ; i < 4 ; i++ )
        {
            /* advance LFSR1 normaly */
            i_t4 = pi_css_tab2[i_t2] ^ pi_css_tab3[i_t1];
            i_t2 = i_t1 >> 1;
            i_t1 = ( ( i_t1 & 1 ) << 8 ) ^ i_t4;
            i_t4 = pi_css_tab5[i_t4];
            /* deduce i_t6 & i_t5 */
            i_t6 = pi_buffer[i];
            if( i_t5 )
            {
                i_t6 = ( i_t6 + 0xff ) & 0x0ff;
            }
            if( i_t6 < i_t4 )
            {
                i_t6 += 0x100;
            }
            i_t6 -= i_t4;
            i_t5 += i_t6 + i_t4;
            i_t6 = pi_css_tab4[ i_t6 ];
            /* feed / advance i_t3 / i_t5 */
            i_t3 = ( i_t3 << 8 ) | i_t6;
            i_t5 >>= 8;
        }

        i_candidate = i_t3;

        /* iterate 6 more times to validate candidate key */
        for( ; i < 10 ; i++ )
        {
            i_t4 = pi_css_tab2[i_t2] ^ pi_css_tab3[i_t1];
            i_t2 = i_t1 >> 1;
            i_t1 = ( ( i_t1 & 1 ) << 8 ) ^ i_t4;
            i_t4 = pi_css_tab5[i_t4];
            i_t6 = ((((((( i_t3 >> 3 ) ^ i_t3 ) >> 1 ) ^
                                         i_t3 ) >> 8 ) ^ i_t3 ) >> 5 ) & 0xff;
            i_t3 = ( i_t3 << 8 ) | i_t6;
            i_t6 = pi_css_tab4[i_t6];
            i_t5 += i_t6 + i_t4;
            if( ( i_t5 & 0xff ) != pi_buffer[i] )
            {
                break;
            }

            i_t5 >>= 8;
        }

        if( i == 10 )
        {
            /* Do 4 backwards steps of iterating t3 to deduce initial state */
            i_t3 = i_candidate;
            for( i = 0 ; i < 4 ; i++ )
            {
                i_t1 = i_t3 & 0xff;
                i_t3 = ( i_t3 >> 8 );
                /* easy to code, and fast enough bruteforce
                 * search for byte shifted in */
                for( j = 0 ; j < 256 ; j++ )
                {
                    i_t3 = ( i_t3 & 0x1ffff) | ( j << 17 );
                    i_t6 = ((((((( i_t3 >> 3 ) ^ i_t3 ) >> 1 ) ^
                                   i_t3 ) >> 8 ) ^ i_t3 ) >> 5 ) & 0xff;
                    if( i_t6 == i_t1 )
                    {
                        break;
                    }
                }
            }

            i_t4 = ( i_t3 >> 1 ) - 4;
            for( i_t5 = 0 ; i_t5 < 8; i_t5++ )
            {
                if( ( ( i_t4 + i_t5 ) * 2 + 8 - ( (i_t4 + i_t5 ) & 7 ) )
                                                                      == i_t3 )
                {
                    (*p_key)[0] = i_try>>8;
                    (*p_key)[1] = i_try & 0xFF;
                    (*p_key)[2] = ( ( i_t4 + i_t5 ) >> 0) & 0xFF;
                    (*p_key)[3] = ( ( i_t4 + i_t5 ) >> 8) & 0xFF;
                    (*p_key)[4] = ( ( i_t4 + i_t5 ) >> 16) & 0xFF;
                    i_exit = i_try + 1;
                }
            }
        }
    }

    if( i_exit >= 0 )
    {
        (*p_key)[0] ^= (*p_sector_key)[0];
        (*p_key)[1] ^= (*p_sector_key)[1];
        (*p_key)[2] ^= (*p_sector_key)[2];
        (*p_key)[3] ^= (*p_sector_key)[3];
        (*p_key)[4] ^= (*p_sector_key)[4];
    }

    return i_exit;
}

/*
 * Authentication and keys
 */

/*****************************************************************************
 * CSSTest : check if the disc is encrypted or not
 *****************************************************************************/
int CSSTest( int i_fd )
{
    dvd_struct dvd;

    dvd.type = DVD_STRUCT_COPYRIGHT;
    dvd.copyright.layer_num = 0;

    if( ioctl( i_fd, DVD_READ_STRUCT, &dvd ) < 0 )
    {
        intf_ErrMsg( "DVD ioctl error" );
        return -1;
    }

    return dvd.copyright.cpst;
}

/*****************************************************************************
 * CSSInit : CSS Structure initialisation and DVD authentication.
 * It simulates the mutual authentication between logical unit and host.
 * ---
 * Since we don't need the disc key to find the title key, we just run the
 * basic unavoidable commands to authenticate device and disc.
 *****************************************************************************/

css_t CSSInit( int i_fd )
{
    /* structures defined in cdrom.h or dvdio.h */
    dvd_authinfo    auth_info;
    dvd_struct      dvd;

    css_t           css;
    int             i_error = -1;
    int             i;

    css.i_fd = i_fd;
    css.b_error = 0;

    memset( &auth_info, 0, sizeof(auth_info) );

    /* Test authentication success */
    switch( CSSGetASF( i_fd ) )
    {
    case -1:
        css.b_error = 1;
    case 1:
        return css;
    case 0:
        intf_WarnMsg( 3, "CSS: Authenticating" );
    }

    /* Init sequence, request AGID */
    for( i = 1; i < 4 ; ++i )
    {
        intf_WarnMsg( 3, "CSS: Request AGID %d", i );
        auth_info.type = DVD_LU_SEND_AGID;
        auth_info.lsa.agid = 0;
        i_error =  ioctl( i_fd, DVD_AUTH, &auth_info );
        if( i_error != -1 )
        {
            /* No error during ioctl: we know if device
             * is authenticated */
            break;
        }

        intf_ErrMsg( "CSS: AGID N/A, invalidating" );
        auth_info.type = DVD_INVALIDATE_AGID;
        auth_info.lsa.agid = 0;
        ioctl( i_fd, DVD_AUTH, &auth_info );
    }

    /* Unable to authenticate without AGID */
    if( i_error == -1 )
    {
        css.b_error = 1;
        intf_ErrMsg( "CSS: Cannot get AGID" );
        return css;
    }

    for( i = 0 ; i < 10; ++i )
    {
        css.disc.pi_challenge[i] = i;
    }

    /* Send AGID to host */
    auth_info.type = DVD_HOST_SEND_CHALLENGE;

    /* Get challenge from host */
    for( i = 0 ; i < 10 ; ++i )
    {
        auth_info.hsc.chal[9-i] = css.disc.pi_challenge[i];
    }
    /* Returning data, let LU change state */
    css.i_agid = auth_info.lsa.agid;

    /* Send challenge to LU */
    if( ioctl( i_fd, DVD_AUTH, &auth_info )<0 )
    {
        intf_ErrMsg( "CSS: Send challenge to LU failed ");
        css.b_error = 1;
        return css;
    }

    /* Get key1 from LU */
    if( ioctl( i_fd, DVD_AUTH, &auth_info ) < 0)
    {
        intf_ErrMsg( "CSS: Get key1 from LU failed ");
        css.b_error = 1;
        return css;
    }

    /* Send key1 to host */
    for( i = 0 ; i < KEY_SIZE ; i++ )
    {
        css.disc.pi_key1[i] = auth_info.lsk.key[4-i];
    }

    for( i = 0 ; i < 32 ; ++i )
    {
        CSSCryptKey( 0, i, css.disc.pi_challenge,
                           css.disc.pi_key_check );

        if( memcmp( css.disc.pi_key_check,
                    css.disc.pi_key1, KEY_SIZE ) == 0 )
        {
            intf_WarnMsg( 3, "CSS: Drive Authentic - using varient %d", i);
            css.disc.i_varient = i;
            auth_info.type = DVD_LU_SEND_CHALLENGE;
            break;
        }
    }

    if( i == 32 )
    {
        intf_ErrMsg( "Drive would not Authenticate" );
        auth_info.type = DVD_AUTH_FAILURE;
        css.b_error = 1;
        return css;
    }

    /* Get challenge from LU */
    if( ioctl( i_fd, DVD_AUTH, &auth_info ) < 0 )
    {
        intf_ErrMsg( "CSS: Get challenge from LU failed ");
        css.b_error = 1;
        return css;
    }

    /* Send challenge to host */
    for( i = 0 ; i < 10 ; ++i )
    {
        css.disc.pi_challenge[i] = auth_info.hsc.chal[9-i];
    }

    CSSCryptKey( 1, css.disc.i_varient, css.disc.pi_challenge,
                                                    css.disc.pi_key2 );
    auth_info.type = DVD_HOST_SEND_KEY2;

    /* Get key2 from host */
    for( i = 0 ; i < KEY_SIZE ; ++i )
    {
        auth_info.hsk.key[4-i] = css.disc.pi_key2[i];
    }
    /* Returning data, let LU change state */

    /* Send key2 to LU */
    if( ioctl( i_fd, DVD_AUTH, &auth_info ) < 0 )
    {
        intf_ErrMsg( "CSS: Send key2 to LU failed (expected)" );
        return css;
    }

    if( auth_info.type == DVD_AUTH_ESTABLISHED )
    {
        intf_WarnMsg( 3, "CSS: Authentication established");
    }
    else if( auth_info.type == DVD_AUTH_FAILURE )
    {
        css.b_error = 1;
        intf_ErrMsg("CSS: DVD authentication failed");
    }

    memcpy( css.disc.pi_challenge, css.disc.pi_key1, KEY_SIZE );
    memcpy( css.disc.pi_challenge+KEY_SIZE, css.disc.pi_key2, KEY_SIZE );
    CSSCryptKey( 2, css.disc.i_varient,
                    css.disc.pi_challenge,
                    css.disc.pi_key_check );

    intf_WarnMsg( 1, "CSS: Received Session Key" );

    if( css.i_agid < 0 )
    {
        css.b_error = 1;
        return css;
    }

    /* Test authentication success */
    switch( CSSGetASF( i_fd ) )
    {
    case -1:
        css.b_error = 1;
    case 1:
        return css;
    case 0:
        intf_WarnMsg( 3, "CSS: Getting disc key" );
    }

    /* Get encrypted disc key */
    dvd.type = DVD_STRUCT_DISCKEY;
    dvd.disckey.agid = css.i_agid;
    memset( dvd.disckey.value, 0, 2048 );

    if( ioctl( i_fd, DVD_READ_STRUCT, &dvd ) < 0 )
    {
        intf_ErrMsg( "CSS: Could not read Disc Key" );
        css.b_error = 1;
        return css;
    }
#if 1
    /* Unencrypt disc key using bus key */
    for( i = 0 ; i < sizeof(dvd.disckey.value) ; i++ )
    {
        dvd.disckey.value[i] ^= css.disc.pi_key_check[4 - (i % KEY_SIZE)];
    }
    memcpy( css.disc.pi_key_check, dvd.disckey.value, 2048 );
#endif
    /* Test authentication success */
    switch( CSSGetASF( i_fd ) )
    {
    case -1:
    case 0:
        css.b_error = 1;
    case 1:
        return css;
    }

    return css;
}

/*****************************************************************************
 * CSSGetKeys : get the title keys.
 * The DVD should have been opened and authenticated before.
 *****************************************************************************/
int CSSGetKeys( css_t * p_css )
{
    /*
     * Title key cracking method from Ethan Hawke,
     * with Frank A. Stevenson algorithm.
     * Does not use any player key table and ioctls.
     */
    u8          pi_buf[0x800] ;
    DVD_key_t   key;
    title_key_t p_title_key[10] ;
    off_t       i_pos;
    boolean_t   b_encrypted;
    boolean_t   b_stop_scanning;
    int         i_title;
    int         i_bytes_read;
    int         i_best_plen;
    int         i_best_p;
    int         i_registered_keys;
    int         i_total_keys_found;
    int         i_highest;
    int         i,j,k;

    for( i_title = 0 ; i_title < p_css->i_title_nb ; i_title++ )
    {
        /* Initialization for each title */
        memset( p_title_key, 0, 10 );
        memset( &key, 0, 10 );
        b_encrypted = 0;
        b_stop_scanning = 0;
        i_registered_keys = 0 ;
        i_total_keys_found = 0 ;
        i_highest = 0;

        /* Position of the title on the disc */
        i_pos = p_css->p_title_key[i_title].i;

//fprintf( stderr, "CSS %d start pos: %lld\n", i_title, i_pos );

        do {
        i_pos = lseek( p_css->i_fd, i_pos, SEEK_SET );
        i_bytes_read = read( p_css->i_fd, pi_buf, 0x800 );

        /* PES_scrambling_control */
        if( pi_buf[0x14] & 0x30 )
        {
            b_encrypted = 1;
            i_best_plen = 0;
            i_best_p = 0;

            for( i = 2 ; i < 0x30 ; i++ )
            {
                for( j = i ; ( j < 0x80 ) &&
                       ( pi_buf[0x7F - (j%i)] == pi_buf[0x7F-j] ) ; j++ );
                {
                    if( ( j > i_best_plen ) && ( j > i ) )
                    {
                        i_best_plen = j;
                        i_best_p = i;
                    }
                }
            }

            if( ( i_best_plen > 20 ) && ( i_best_plen / i_best_p >= 2) )
            {
                i = CSSCracker( 0,  &pi_buf[0x80],
                        &pi_buf[0x80 - ( i_best_plen / i_best_p) *i_best_p],
                        (DVD_key_t*)&pi_buf[0x54],
                        &key );
                while( i>=0 )
                {
                    k = 0;
                    for( j=0 ; j<i_registered_keys ; j++ )
                    {
                        if( memcmp( &(p_title_key[j].key),
                                    &key, sizeof(DVD_key_t) ) == 0 )
                        {
                            p_title_key[j].i++;
                            i_total_keys_found++;
                            k = 1;
                        }
                    }

                    if( k == 0 )
                    {
                        memcpy( &(p_title_key[i_registered_keys].key),
                                                &key, sizeof(DVD_key_t) );
                        p_title_key[i_registered_keys++].i = 1;
                        i_total_keys_found++;
                    }
                    i = CSSCracker( i, &pi_buf[0x80],
                        &pi_buf[0x80 -( i_best_plen / i_best_p) *i_best_p],
                        (DVD_key_t*)&pi_buf[0x54], &key);
                }

                /* Stop search if we find two occurances of the key */
                if( i_registered_keys == 1 && p_title_key[0].i >= 2 )
                {
                    b_stop_scanning = 1;
                }
            }
        }

        i_pos += i_bytes_read;
        } while( i_bytes_read == 0x800 && !b_stop_scanning);

        if( b_stop_scanning)
        {
            intf_WarnMsg( 1,
                "CSS: Found enough occurancies of the same key." );
        }

        if( !b_encrypted )
        {
            intf_WarnMsg( 3, "CSS: This file was _NOT_ encrypted!");
            return(0);
        }

        if( b_encrypted && i_registered_keys == 0 )
        {
            intf_ErrMsg( "CSS: Unable to determine keys from file.");
            return(1);
        }

        for( i = 0 ; i < i_registered_keys - 1 ; i++ )
        {
            for( j = i + 1 ; j < i_registered_keys ; j++ )
            {
                if( p_title_key[j].i > p_title_key[i].i )
                {
                    memcpy( &key, &(p_title_key[j].key), sizeof(DVD_key_t) );
                    k = p_title_key[j].i;

                    memcpy( &(p_title_key[j].key),
                            &(p_title_key[i].key), sizeof(DVD_key_t) );
                    p_title_key[j].i = p_title_key[i].i;

                    memcpy( &(p_title_key[i].key),&key, sizeof(DVD_key_t) );
                    p_title_key[i].i = k;
                }
            }
        }

#ifdef STATS
        intf_WarnMsg( 1, " Key(s) & key probability\n---------------------");
#endif
        for( i=0 ; i<i_registered_keys ; i++ )
        {
#ifdef STATS
            intf_WarnMsg( 1, "%d) %02X %02X %02X %02X %02X - %3.2f%%", i,
                        p_title_key[i].key[0], p_title_key[i].key[1],
                        p_title_key[i].key[2], p_title_key[i].key[3],
                        p_title_key[i].key[4],
                        p_title_key[i].i * 100.0 / i_total_keys_found );
#endif
            if( p_title_key[i_highest].i * 100.0 / i_total_keys_found
                               <= p_title_key[i].i*100.0 / i_total_keys_found )
            {
                i_highest = i;
            }
        }


        /* The "find the key with the highest probability" code
         * is untested, as I haven't been able to find a VOB that
         * produces multiple keys (RT)
         */
        intf_WarnMsg( 3, "CSS: Title %d key: %02X %02X %02X %02X %02X",
                    i_title + 1,
                    p_title_key[i_highest].key[0],
                    p_title_key[i_highest].key[1],
                    p_title_key[i_highest].key[2],
                    p_title_key[i_highest].key[3],
                    p_title_key[i_highest].key[4] );

        memcpy( p_css->p_title_key[i_title].key,
                p_title_key[i_highest].key, KEY_SIZE );
    }

    return 0;
}

/*****************************************************************************
 * CSSDescrambleSector
 * ---
 * sec : sector to descramble
 * key : title key for this sector
 *****************************************************************************/
int CSSDescrambleSector( DVD_key_t key, u8* pi_sec )
{
    unsigned int    i_t1, i_t2, i_t3, i_t4, i_t5, i_t6;
    u8*             pi_end = pi_sec + 0x800;

    /* PES_scrambling_control */
    if( pi_sec[0x14] & 0x30)
    {
        i_t1 = ((key)[0] ^ pi_sec[0x54]) | 0x100;
        i_t2 = (key)[1] ^ pi_sec[0x55];
        i_t3 = (((key)[2]) | ((key)[3] << 8) |
               ((key)[4] << 16)) ^ ((pi_sec[0x56]) |
               (pi_sec[0x57] << 8) | (pi_sec[0x58] << 16));
        i_t4 = i_t3 & 7;
        i_t3 = i_t3 * 2 + 8 - i_t4;
        pi_sec += 0x80;
        i_t5 = 0;

        while( pi_sec != pi_end )
        {
            i_t4 = pi_css_tab2[i_t2] ^ pi_css_tab3[i_t1];
            i_t2 = i_t1>>1;
            i_t1 = ( ( i_t1 & 1 ) << 8 ) ^ i_t4;
            i_t4 = pi_css_tab5[i_t4];
            i_t6 = ((((((( i_t3 >> 3 ) ^ i_t3 ) >> 1 ) ^
                                         i_t3 ) >> 8 ) ^ i_t3 ) >> 5) & 0xff;
            i_t3 = (i_t3 << 8 ) | i_t6;
            i_t6 = pi_css_tab4[i_t6];
            i_t5 += i_t6 + i_t4;
            *pi_sec++ = pi_css_tab1[*pi_sec] ^( i_t5 & 0xff );
            i_t5 >>= 8;
        }
    }

    return(0);
}
#endif
